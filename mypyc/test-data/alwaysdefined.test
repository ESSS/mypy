-- Test cases for always defined attributes.
--
-- If class C has attributes x and y that are always defined, the output will
-- have a line like this:
--
--   C: [x, y]

[case testAlwaysDefinedSimple]
class C:
    def __init__(self, x: int) -> None:
        self.x = x
[out]
C: [x]

[case testAlwaysDefinedFail]
class MethodCall:
    def __init__(self, x: int) -> None:
        self.f()
        self.x = x

    def f(self) -> None:
        pass

class FuncCall:
    def __init__(self, x: int) -> None:
        f()
        self.x = x

class GetAttr:
    x: int
    def __init__(self, x: int) -> None:
        a = self.x
        self.x = x

class _Base:
    def  __init__(self) -> None:
        f()

class CallSuper(_Base):
    def __init__(self, x: int) -> None:
        super().__init__()
        self.x = x

class Lambda:
    def __init__(self, x: int) -> None:
        f = lambda x: x + 1
        self.x = x
        g = lambda x: self
        self.y = x

class If:
    def __init__(self, x: int) -> None:
        self.a = 1
        if x:
            self.x = x
        else:
            self.y = 1

def f() -> None: pass
[out]
MethodCall: []
FuncCall: []
GetAttr: []
CallSuper: []
Lambda: []
If: [a]

[case testAlwaysDefinedConditional]
class IfAlways:
    def __init__(self, x: int, y: int) -> None:
        if x:
            self.x = x
            self.y = y
        elif y:
            self.x = y
            self.y = x
        else:
            self.x = 0
            self.y = 0
        self.z = 0

class IfSometimes1:
    def __init__(self, x: int, y: int) -> None:
        if x:
            self.x = x
            self.y = y
        elif y:
            self.z = y
            self.y = x
        else:
            self.y = 0
            self.a = 0

class IfSometimes2:
    def __init__(self, x: int, y: int) -> None:
        if x:
            self.x = x
        self.y = y

class IfStopAnalysis1:
    def __init__(self, x: int, y: int) -> None:
        if x:
            self.x = x
            f()
        else:
            self.x = x
        self.y = y

class IfStopAnalysis2:
    def __init__(self, x: int, y: int) -> None:
        if x:
            self.x = x
        else:
            self.x = x
            f()
        self.y = y

class IfStopAnalysis3:
    def __init__(self, x: int, y: int) -> None:
        if x:
            self.x = x
        else:
            f()
            self.x = x
        self.y = y

class IfConditionalAndNonConditional1:
    def __init__(self, x: int) -> None:
        self.x = 0
        if x:
            self.x = x

class IfConditionalAndNonConditional2:
    def __init__(self, x: int) -> None:
        # x is not considered always defined, since the second assignment may
        # either initialize or update.
        if x:
            self.x = x
        self.x = 0

def f() -> None: pass
[out]
IfAlways: [x, y, z]
IfSometimes1: [y]
IfSometimes2: [y]
IfStopAnalysis1: [x]
IfStopAnalysis2: [x]
IfStopAnalysis3: []
IfConditionalAndNonConditional1: [x]
IfConditionalAndNonConditional2: []

[case testAlwaysDefinedExpressions]
from typing import Dict, Set, Optional
from typing_extensions import Final

import other

class C: pass

class Collections:
    def __init__(self, x: int) -> None:
        self.l = [x]
        self.d: Dict[str, str] = {}
        self.s: Set[int] = set()
        self.d2 = {'x': x}  # Can call __hash__ and __eq__
        self.s2 = {x}  # Can call __hash__ and __eq__
        self.l2 = [f()]

class Comparisons:
    def __init__(self, y: int, c: C, s: str, o: Optional[str]) -> None:
        self.n1 = y < 5
        self.n2 = y == 5
        self.c1 = y is c
        self.c2 = y is not c
        self.o1 = o is None
        self.o2 = o is not None
        self.s = s < 'x'

class BinaryOps:
    def __init__(self, x: int, s: str) -> None:
        self.a = x + 2
        self.b = x & 2
        self.c = x * 2
        self.d = -x
        self.f = x << x
        self.e = 'x' + s

g = 2

class LocalsAndGlobals:
    def __init__(self, x: int) -> None:
        t = x + 1
        self.a = t - t
        self.g = g

class Booleans:
    def __init__(self, x: int, b: bool) -> None:
        self.a = True
        self.b = False
        self.c = not b
        self.d = b or b
        self.e = b and b

F: Final = 3

class ModuleFinal:
    def __init__(self) -> None:
        self.a = F
        self.b = other.Y

class Literals:
    def __init__(self) -> None:
        self.a = 'x'
        self.b = b'x'
        self.c = 2.2

def f() -> int:
    return 0

[file other.py]
# Not compiled
from typing_extensions import Final

Y: Final = 3

[out]
C: []
Collections: [d, l, s]
Comparisons: [c1, c2, n1, n2, o1, o2]
BinaryOps: [a, b, c, d, f]
LocalsAndGlobals: [a]
Booleans: [a, b, c, d, e]
ModuleFinal: [a, b]
Literals: [a, b, c]

[case testAlwaysDefinedExpressions2]
from typing import List, Tuple

class C:
    def __init__(self) -> None:
        self.x = 0

class AttributeRef:
    def __init__(self, c: C) -> None:
        self.aa = c.x
        self.bb = self.aa
        if c is not None:
            self.z = 0
        self.cc = 0
        self.dd = self.z

class ListOps:
    def __init__(self, x: List[int], n: int) -> None:
        self.a = len(x)
        self.b = x[n]
        self.c = [y + 1 for y in x]

class TupleOps:
    def __init__(self, t: Tuple[int, str]) -> None:
        x, y = t
        self.x = x
        self.y = t[0]
        s = x, y
        self.z = s

class IfExpr:
    def __init__(self, x: int) -> None:
        self.a = 1 if x < 5 else 2

class Base:
    def __init__(self, x: int) -> None:
        # TODO: x should be always defined
        self.x = x

class Derived1(Base):
    def __init__(self, y: int) -> None:
        # TODO: x and bb should also be always defined
        self.aa = y
        super().__init__(y)
        self.bb = y

class Derived2(Base):
    # TODO: x should be always defined
    pass

class Conditionals:
    def __init__(self, b: bool, n: int) -> None:
        if b:
            self.a = b
        else:
            self.a = not b
        if not (n == 5 or n >= n + 1):
            self.b = 2
        else:
            self.b = 4

[out]
C: [x]
AttributeRef: [aa, bb, cc, dd]
ListOps: [a, b, c]
TupleOps: [x, y, z]
IfExpr: [a]
Base: []
Derived1: [aa]
Derived2: []
Conditionals: [a, b]

[case testAlwaysDefinedStatements]
from typing import List, Optional

class Return:
    def __init__(self, x: int) -> None:
        self.x = x
        if x > 5:
            self.y = 1
            return
        self.y = 2
        self.z = x

class While:
    def __init__(self, x: int) -> None:
        n = 2
        while x > 0:
            n *=2
            x -= 1
        self.a = n
        while x < 5:
            self.b = 1
            self.b += 1

class Try:
    def __init__(self, x: List[int]) -> None:
        self.a = 0
        try:
            self.b = x[0]
        except:
            self.c = x
        self.d = 0

def f() -> None:
    pass

[out]
Return: [x, y]
While: [a]
Try: [a]
